# FOGGS_SlimeFire
 SlimeFire game for FOGGS

## Introduction
This was a university project where I was tasked with creating a 2D game with semblance to Pacman (as this is what we were taught based on), without the use of an engine. This meant that the game was created without the use of any visual development such as “dragging and dropping”, and instead everything was manually coded, loaded and implemented using C++ and an API provided by the university named ‘S2D’, which handled much of the actual loading of assets, such as correctly importing and processing files. 

## What Went Well/Wrong
One aspect of this project which I believe went particularly well was the use of basic AI in my game. In the given tutorial of creating AI for our games, I was taught how to create an enemy which simply moves right until it hits a wall, and consequently moves in the opposite direction. I then took this and developed it so that the enemies could move up and down as well following the same rules, but quickly realised that an enemy would only ever move vertically or horizontally. To fix this, I made use of the ‘rand’ keyword so that every few seconds each enemy would be assigned a new direction (on individual timers so that they didn’t all switch at once). I further improved this by added an ‘idle’ state, where enemies would, for a few seconds, rapidly switch directions to make them seem as though they were flickering around a small area, as the enemies were meant to resemble flames. Finally, I added rules so that if the player were to get too close to an enemy, they would lock onto the player and try to touch them but would also slow down to give the player chance to escape. This taught me that in simple AI such as this, ‘AI’ isn’t much more than many different rules that an object should follow, depending on the situation. 

An issue I ran into during development, which I was stuck on for a few days, was that one of my audio files wouldn’t play for an unknown reason. When swapping the file out for example file provided by the university, it worked perfectly, so I knew that the code was working as intended. I assumed that meant that my file was the issue, so I tried a different one – but this still didn’t work and therefore left me very confused. After getting some help in a tutorial lesson, it turned out that both files were the problem, and it was because the bitrates of both files were outside of the parameters accounted for by S2D. This taught me that, whilst the type of file was correct, there are other properties to look out for in external files which may cause issues with the program. 

## Conclusion
If I were to do this project again, I would likely put more emphasis on the aesthetics of the game, as I’ve realised that whilst the programming of a game can be impressive, having bad graphics will automatically make the game look worse from an external view – especially if this is a customer for example, without context in the difficulty of the programming.

In addition to what I’ve already stated I’ve learned, I would also like to add that this project has allowed me to understand the importance of structure in code further, as it not only plays a big role in allowing others to understand the code, but also in the functionality of the program. For example, with the use of an update method in my game, the majority of the code was being ran many times every second, which meant that additional measures had to be taken for some aspects in the code to prevent bugs. An example of this is the pause button, whereby outside of the update method pressing ‘p’ (the pause button) would only cause one instance, but because ‘p’ was being checked so many times for if it was down, the game would pause and play rapidly without an additional check for if ‘p’ had been lifted again.

 I found the inclusion of external files in my game to be the hardest aspect of it, and in future I would like to learn about tile-mapping for 2D games such as this. Given the time and knowledge, I could potentially use tile-mapping as a way to create levels in the game, where after reaching a certain score the next level with new enemies would begin, and, using tile-mapping to easily create different maps, the layout of the game screen would change to include new objects (tiles) with differing effects on the player, for example walls that block the player, water which slows the player down, lava which kills the player, etc. As of the time of writing, I have looked a little into tile-mapping and understand the concept of using a 2D array to split the game into squares, but then I find difficulty in how to properly assign different tiles their textures and properties, and how to smoothly blend this code into the rest of the program. I would also like to further investigate how C++’s fstream works.
 
 ### YouTube video demonstration of game
 <https://youtu.be/-7vrSUHFIr4>
